import numpy as np
from enum import Enum
from random import uniform, choices
import json
from pathlib import Path

from utils import attraction_to_radius, attraction_decay, Action, ActionType, ContextRequest, Point, ModifierType, visualize_probabilities

# Default global config file
base_path = Path(__file__).parent
file_path = (base_path / "../engine/config.json").resolve()
CONFIG = None
with open(file_path, "r") as config_file:
    CONFIG = json.load(config_file)

class CellStatus(Enum):
    DEAD = 0
    ALIVE = 1


class Cell:
    def __init__(self, p_migrate=0, p_prolif=0, attraction_generated=0):
        """Base class for all class cells, defines the interface.

        Args:
            p_migrate (int, optional): chance of the cell to move. Defaults to 0.
            p_prolif (int, optional): change of the cell to proliferate. Defaults to 0.
            attraction_generated (int, optional): amount of attraction generated by the cell. Defaults to 0.
        """
        self.attraction_generated = attraction_generated
        self.p_migrate = p_migrate
        self.p_prolif = p_prolif
        self.attraction_matrix = self.init_attraction_matrix()

    def get_actions(self, grid_context: dict):
        """Returns list of actions the the cell wants to do. Called every iteration by the board.

        Args:
            grid_context (dict): information needed by the cell to decide on his actions.

        Returns:
            list[Action]
        """
        return []

    def get_context(self):
        """Returns a list containing the type(s) of information required by the cell

        Returns:
            List[ContextRequest]
        """
        return []

    def is_alive(self):
        return self.status == CellStatus.ALIVE

    def get_modifiers(self):
        """ Returns a dictionary whose keys are modifier types and values are the modifier values.
        """
        return {ModifierType.ATTRACTION_MATRIX: self.attraction_matrix}

    def choose_direction(self, grid_context) -> Point:
        """ Generic function to choose a direction with probability based to potential (attraction) around the given cell

        Args:
            grid_context (dict): dictionary containing information about the neighborhood of the cell

        Returns:
            Point: Chosen direction (relative)
        """
        direction = Point(0, 0)  # Default is no movement

        # Get a dict with tile:attraction pairs (e.g. (1,1):3.1)
        attractions = grid_context[ContextRequest.ATTRACTION_IN_NEIGHBORHOOD]
        attraction_sum = sum(attractions.values())

        if (attraction_sum):  # If there is attraction.
            options = []
            probs = []

            # Generate a list of optional directions and probabilities.
            for neighbor_tile in attractions:
                # For each direction
                options.append(neighbor_tile)
                attraction = attractions[neighbor_tile]

                # Calculate probability

                # If information regarding the neighbors of the neighbors was provided, use this information to penalize directions
                # which already have many cells. This simulates the mechanical pressure, which create a repulsive effect.
                if (ContextRequest.NEIGHBORS_NEIGHBORS in grid_context):
                    num_neighbors_neighbors = grid_context[ContextRequest.NEIGHBORS_NEIGHBORS][neighbor_tile]
                    probs.append(
                        (attraction/num_neighbors_neighbors) / attraction_sum)
                else:
                    probs.append((attraction) / attraction_sum)

            # Debug capabilities
            if (CONFIG["debug"]):
                visualize_probabilities(list(attractions.values()), probs)

            # Choose a direction
            direction = choices(options, probs)[0]

        return direction

    def generate_actions_by_attraction(self, grid_context, cond: bool, action_type: ActionType):
        """ Generic function that creates the action list for the cell, based on a given condition.

        Args:
            grid_context (List): Information about the grid.
            cond (bool): Given condition.
            action_type (ActionType): ActionType to create

        Returns:
            List[Action]
        """
        actions = []

        # Assert the the condition is fulfilled
        if (cond):
            direction = self.choose_direction(grid_context)
            if (direction != Point(0, 0)):  # Cannot act on yourself
                actions.append(Action(dst=direction, type=action_type))

        return actions

    def init_attraction_matrix(self):
        """Create the attraction matrix, limiting it's size only to significant changes.

        Returns:
            int[][]: The attraction matrix
        """
        radius = attraction_to_radius(
            self.attraction_generated)  # Maximal radius according to precision defined in the config.
        center = Point(radius, radius)
        # 2*radius+1 because we want the center to be the cell itself
        mat = np.zeros(shape=((2*radius)+1, (2*radius)+1), dtype=float)

        # For each cell in the neighborhood of size radius, calculate the attraction.
        for (x, y), attraction in np.ndenumerate(mat):
            mat[x][y] = attraction_decay(
                self.attraction_generated, Point(x, y).dist(center))

        return mat


class TipCell(Cell):
    """Class for a migrating cell that drags stalk cells as he moves."""

    def __init__(self, p_migrate=CONFIG["defaults"]["tip_cell"]["p_migrate"]):
        # Call parent constructor
        Cell.__init__(self, p_migrate=p_migrate)

    def get_actions(self, grid_context):
        """ Returns the migration action for the board to execute.
        """
        return self.generate_actions_by_attraction(grid_context=grid_context, cond=self.should_migrate(), action_type=ActionType.MIGRATE)

    def get_context(self):
        """ Returns the required context for this cells actions.
            ATTRACTION_IN_NEIGHBORHOOD : required in order to choose the direction of migration according to attraction.
        """
        return [ContextRequest.ATTRACTION_IN_NEIGHBORHOOD, ContextRequest.NEIGHBORS_NEIGHBORS]

    def should_migrate(self):
        """This cell has a chance of p_migrate to move.

        Returns:
            bool: should this cell migrate in the current iteration.
        """
        return (uniform(0, 1) < self.p_migrate)


class StalkCell(Cell):
    """Class for a proliferative cell, capable of sprouting into new tips"""

    def __init__(self, p_sprout=CONFIG["defaults"]["stalk_cell"]["p_sprout"]):
        Cell.__init__(self)
        self.p_sprout = p_sprout
        self.count_prolif = 0

    def get_context(self):
        """Returns the required context for this cells actions.
           ATTRACTION_IN_NEIGHBORHOOD : required in order to choose the direction of sprouting according to attraction.
           NEIGHBORS_NEIGHBORS: sprouting occurs in less populated directions.
        """
        return [ContextRequest.ATTRACTION_IN_NEIGHBORHOOD, ContextRequest.NEIGHBORS_NEIGHBORS]

    def get_actions(self, grid_context):
        return self.generate_actions_by_attraction(grid_context, self.should_sprout(grid_context), ActionType.SPROUT)

    def should_sprout(self, grid_context):
        return (uniform(0, 1) < self.p_sprout)


class AttractorCell(Cell):
    """Class for a cell that attracts tip cells"""

    def __init__(self, attraction_generated=CONFIG["defaults"]["attractor_cell"]["attraction_generated"]):
        Cell.__init__(self, attraction_generated=attraction_generated)
